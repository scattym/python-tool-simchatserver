#!/usr/bin/env python
# chat_client.py

import sys
import socket
import select
import argparse
import logging
from sim_chat_lib.meitrack import stub_processor
from sim_chat_lib.meitrack.gprs_protocol import parse_data_payload


def chat_client(host, port, imei, version):
    imei = imei.encode()

    gprs_list, before, after = parse_data_payload(
        b"$$`164,864507032228727,AAA,35,24.818910,121.025936,180329052345,A,7,13,0,16,1.2,69,2720,86125,466|97|527B|01035DB4,0000,0001|0000|0000|019E|097F,00000001,,3,,,124,96*F2\r\n"
    )
    if len(gprs_list) != 1:
        sys.exit(1)

    gprs = gprs_list[0]
    gprs.imei = imei
    message = gprs.as_bytes()
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)

    # connect to remote host
    try:
        s.connect((host, port))
        s.send(message)
    except Exception as err:
        print('Unable to connect: %s' % (err,))
        sys.exit()

    print('Connected to remote host. You can start sending messages')
    sys.stdout.write('[Me] ')
    sys.stdout.flush()

    while 1:
        socket_list = [sys.stdin, s]

        # Get the list sockets which are readable
        ready_to_read, ready_to_write, in_error = select.select(socket_list, [], [])

        for sock in ready_to_read:
            if sock == s:
                # incoming message from remote server, s
                data = sock.recv(4096)

                if not data:
                    print('\nDisconnected from chat server')
                    sys.exit()
                else:
                    sys.stdout.write("\n")
                    print(data)
                    sys.stdout.write(data.decode())
                    gprs_list, before, after = parse_data_payload(data)
                    for gprs in gprs_list:
                        command = gprs.enclosed_data.as_bytes()
                        response = stub_processor.request_to_response(command, imei)
                        if response:
                            print("Sending response %s" % (response,))
                            s.send(response)
                        else:
                            print("No response to send for incoming command {}".format(command))
                    sys.stdout.write('[Me] ')
                    sys.stdout.flush()
            else:
                # user entered a message
                msg = sys.stdin.readline().rstrip()
                if msg.rstrip() == "enctest":
                    data = "This is a test string for encryption"
                else:
                    s.send(("%s%s" % (msg, "\r\n")).encode())
                sys.stdout.write('[Me] ')
                sys.stdout.flush()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument(
        '-i',
        '--imei',
        help="The imei to use in the connect string.",
        default="0407",
    )
    parser.add_argument(
        '-o',
        '--host',
        help="The host to connect to.",
        default="localhost",
    )

    parser.add_argument(
        '-p',
        '--port',
        help="The port for the webserver to listen on.",
        type=int,
        default=65533
    )
    parser.add_argument(
        '-r',
        '--version',
        help="The protocol version to use.",
        type=int,
        default=1
    )
    parser.add_argument(
        '-v',
        dest='debug',
        help=("Increase the logging level. Can specify this option multiple "
              "times for more detail."),
        action="count",
        default=0
    )

    args = parser.parse_args()

    log_level = 11 - args.debug

    logger = logging.getLogger('')
    logger.setLevel(logging.INFO)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    if args.debug:
        logger.setLevel(log_level)
        ch.setLevel(log_level)

    sys.exit(chat_client(args.host, args.port, args.imei, args.version))