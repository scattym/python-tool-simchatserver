#!/usr/bin/env python
import argparse
import logging
import json

import pika
import psycopg2

import asyncio
import aio_pika
import json
import datetime
import os

from geotool_db_api.battery_api import get_update_battery_coroutine
from geotool_db_api.common import create_pool_a
from geotool_db_api.device_api import get_device_id
from geotool_db_api.event_api import get_insert_eventlog_coroutine
from geotool_db_api.input_output_api import get_insert_analogue_io_coroutine, get_insert_digital_io_coroutine

MQ_HOST = os.environ.get("MQ_HOST", "127.0.0.1")
MQ_USER = os.environ.get("MQ_USER", "guest")
MQ_PASS = os.environ.get("MQ_PASS", "guest")

logger = logging.getLogger(__name__)

async def main_event(loop):
    connection = await aio_pika.connect_robust("amqp://{}:{}@{}/".format(MQ_USER, MQ_PASS, MQ_HOST), loop=loop)

    queue_name = "event_log"

    # Creating channel
    channel = await connection.channel()    # type: aio_pika.Channel

    # Declaring queue
    queue = await channel.declare_queue(queue_name)   # type: aio_pika.Queue
    imei_map = {}

    async for message in queue:
        with message.process():
            print(message.body)
            data = json.loads(message.body)
            if data.get("imei", None):
                if imei_map.get(data["imei"]):
                    device_id = imei_map.get(data["imei"])
                else:
                    device_id = await get_device_id(data["imei"])
                    if device_id:
                        imei_map[data["imei"]] = device_id
            elif data.get("device", None):
                device_id = data["device"]

            print("Device id is %s" % (device_id,))
            if '.' not in data["timestamp"]:
                data["timestamp"] = "{}.0".format(data["timestamp"])
            timestamp = datetime.datetime.strptime(data["timestamp"], "%Y-%m-%d %H:%M:%S.%f")
            if "." not in data["log_time"]:
                data["log_time"] = "{}.0".format(data["log_time"])
            log_time = datetime.datetime.strptime(data["log_time"], "%Y-%m-%d %H:%M:%S.%f")
            if device_id:
                loop.create_task(get_insert_eventlog_coroutine(
                    device_id, timestamp, data["event_description"], str(data["event_type"]), log_time,
                ))

            if queue.name in message.body.decode():
                break


async def main_analogue_io(loop):
    connection = await aio_pika.connect_robust("amqp://{}:{}@{}/".format(MQ_USER, MQ_PASS, MQ_HOST), loop=loop)

    queue_name = "analogue_io"

    # Creating channel
    channel = await connection.channel()  # type: aio_pika.Channel

    # Declaring queue
    queue = await channel.declare_queue(queue_name)  # type: aio_pika.Queue
    imei_map = {}

    async for message in queue:
        with message.process():
            print(message.body)
            data = json.loads(message.body)
            if data.get("imei", None):
                if imei_map.get(data["imei"]):
                    device_id = imei_map.get(data["imei"])
                else:
                    device_id = await get_device_id(data["imei"])
                    if device_id:
                        imei_map[data["imei"]] = device_id
            elif data.get("device", None):
                device_id = data["device"]

            print("Device id is %s" % (device_id,))

            ####
            # Handle GPS UPDATE MESSAGES
            if data.get("pin") is not None:
                if '.' not in data["timestamp"]:
                    data["timestamp"] = "{}.0".format(data["timestamp"])
                timestamp = datetime.datetime.strptime(data["timestamp"], "%Y-%m-%d %H:%M:%S.%f")
                insert_coroutine = get_insert_analogue_io_coroutine(
                    device_id,
                    int(data.get("pin")),
                    float(data.get("value")),
                    timestamp
                )
                loop.create_task(insert_coroutine)
                # loop.run_until_complete(update_coroutine)
            else:
                logger.error("Unknown command %s", data)

            if queue.name in message.body.decode():
                break


async def main_digital_io(loop):
    connection = await aio_pika.connect_robust("amqp://{}:{}@{}/".format(MQ_USER, MQ_PASS, MQ_HOST), loop=loop)

    queue_name = "digital_io"

    # Creating channel
    channel = await connection.channel()  # type: aio_pika.Channel

    # Declaring queue
    queue = await channel.declare_queue(queue_name)  # type: aio_pika.Queue
    imei_map = {}

    async for message in queue:
        with message.process():
            print(message.body)
            data = json.loads(message.body)
            if data.get("imei", None):
                if imei_map.get(data["imei"]):
                    device_id = imei_map.get(data["imei"])
                else:
                    device_id = await get_device_id(data["imei"])
                    if device_id:
                        imei_map[data["imei"]] = device_id
            elif data.get("device", None):
                device_id = data["device"]

            print("Device id is %s" % (device_id,))

            ####
            # Handle GPS UPDATE MESSAGES
            if data.get("pin") is not None:
                if '.' not in data["timestamp"]:
                    data["timestamp"] = "{}.0".format(data["timestamp"])
                timestamp = datetime.datetime.strptime(data["timestamp"], "%Y-%m-%d %H:%M:%S.%f")
                insert_coroutine = get_insert_digital_io_coroutine(
                    device_id,
                    int(data.get("pin")),
                    bool(data.get("value")),
                    timestamp
                )
                loop.create_task(insert_coroutine)
                # loop.run_until_complete(update_coroutine)
            else:
                logger.error("Unknown command %s", data)

            if queue.name in message.body.decode():
                break


async def main_battery_update(loop):
    connection = await aio_pika.connect_robust("amqp://{}:{}@{}/".format(MQ_USER, MQ_PASS, MQ_HOST), loop=loop)

    queue_name = "battery_update"

    # Creating channel
    channel = await connection.channel()  # type: aio_pika.Channel

    # Declaring queue
    queue = await channel.declare_queue(queue_name)  # type: aio_pika.Queue
    imei_map = {}

    async for message in queue:
        with message.process():
            print(message.body)
            data = json.loads(message.body)
            if data.get("imei", None):
                if imei_map.get(data["imei"]):
                    device_id = imei_map.get(data["imei"])
                else:
                    device_id = await get_device_id(data["imei"])
                    if device_id:
                        imei_map[data["imei"]] = device_id
            elif data.get("device", None):
                device_id = data["device"]
            elif data.get("primary_key") is not None:
                device_id = data.get("primary_key")

            print("Device id is %s" % (device_id,))

            ####
            # Handle GPS UPDATE MESSAGES
            if data.get("battery_level") is not None:

                # (device_id: int, battery_in_use: bool, battery_voltage: str, battery_level: str):
                insert_coroutine = get_update_battery_coroutine(
                    device_id,
                    None,
                    data.get("battery_voltage"),
                    data.get("battery_level")
                )
                loop.create_task(insert_coroutine)
                # loop.run_until_complete(update_coroutine)
            else:
                logger.error("Unknown command %s", data)

            if queue.name in message.body.decode():
                break


if __name__ == "__main__":
    if __name__ == "__main__":

        parser = argparse.ArgumentParser(
            formatter_class=argparse.ArgumentDefaultsHelpFormatter
        )
        parser.add_argument(
            '-l',
            '--line-numbers',
            help="Don't include line numbers in logging output",
            action="store_false",
            default=True,
        )
        parser.add_argument(
            '-v',
            dest='debug',
            help=("Increase the logging level. Can specify this option multiple "
                  "times for more detail."),
            action="count",
            default=int(os.environ.get('DEBUG_LEVEL', 0))
        )
        args = parser.parse_args()

        log_level = 16 - args.debug

        logger = logging.getLogger('')
        logger.setLevel(logging.INFO)

        ch = logging.StreamHandler()
        ch.setLevel(logging.DEBUG)
        formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(name)s - %(message)s'
        )
        if args.line_numbers:
            formatter = logging.Formatter(
                '%(asctime)s - %(process)d - %(levelname)s - %(name)s - %(lineno)d - %(message)s'
            )
        ch.setFormatter(formatter)
        logger.addHandler(ch)

        # almost time to look into kombu
        logging.getLogger("pika").setLevel(logging.FATAL)

        if args.debug:
            logger.setLevel(log_level)
            ch.setLevel(log_level)

    loop = asyncio.get_event_loop()
    loop.run_until_complete(create_pool_a())
    print("Event processor has started.")
    loop.create_task(main_event(loop))
    loop.create_task(main_analogue_io(loop))
    loop.create_task(main_digital_io(loop))
    loop.create_task(main_battery_update(loop))
    loop.run_forever()