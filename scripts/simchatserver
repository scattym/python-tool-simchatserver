#!/usr/bin/env python

# chat_server.py
import sys
import socket
import select
import argparse
import logging
import os
from sim_chat_lib.geotool_api.common import set_api_host

import sim_chat_lib
from sim_chat_lib.exception import Error as SimChatError
from sim_chat_lib.exception import ProtocolError
from sim_chat_lib.report.async_api import start_consumers, get_result, stop_consumers

HOST = ''
RECV_BUFFER = 4096
PORT = 65533

MASTER_LIST = []
logger = logging.getLogger(__name__)

CHAT_CLIENT_LIST = {}
CHAT_CLIENT_IDENT_LIST = {}
connections = {}
QUIT_FLAG = False
epoll = select.epoll()


def close_socket(sock):
    global epoll
    logger.debug("Closing socket %s", sock)
    sock_fd = sock.fileno()
    peer = [None, None]
    try:
        peer = sock.getpeername()
    except socket.error as err:
        logger.error("Socket error on getting peer %s", err)

    # for key in SOCKET_MAP:
    #     if SOCKET_MAP[key] == sock_fd:
    #         logger.info("Client %s (%s, %s) is offline", key, peer[0], peer[1])
    #         SOCKET_MAP[key] = None

    if CHAT_CLIENT_LIST.get(sock_fd):
        logger.debug("Found the socket in the chat client list")
        ident = CHAT_CLIENT_LIST[sock_fd].ident()
        CHAT_CLIENT_IDENT_LIST[ident] = None
        CHAT_CLIENT_LIST[sock_fd] = None

    if sock in MASTER_LIST:
        logger.info("Master disconnected from %s", sock)
        MASTER_LIST.remove(sock)
        # return

    logger.debug("Unregistering socket fd %s from epoll", sock.fileno())
    epoll.unregister(sock.fileno())
    connections[sock.fileno()] = None

    try:
        sock.close()
        logger.info("Socket closed")
    except socket.error as err:
        logger.error("Socket error on close %s", err)


def execute_command(data):
    global QUIT_FLAG
    logger.info("Executing command: %s", data)
    if ',' in data:
        line = data.split(",", 1)
        imei = line[0]
        cmd = line[1]
        send_to_device(imei, cmd)
    else:
        if data == "list":
            for sock in MASTER_LIST:
                try:
                    peer = sock.getpeername()
                    logger.info("Master is connected from %s:%s" % (peer[0], peer[1]))
                    send_to_masters("Master is connected from %s:%s" % (peer[0], peer[1]))
                except socket.error:
                    close_socket(sock)
            logger.debug("%s", CHAT_CLIENT_LIST)
            for sock_fd in CHAT_CLIENT_LIST:
                logger.debug("Sockfd: %s", sock_fd)
                if CHAT_CLIENT_LIST[sock_fd]:
                    message = CHAT_CLIENT_LIST[sock_fd].get_client_details()
                    logger.debug(message)
                    send_to_masters(message)
        if data == "debug":
            root_logger = logging.getLogger('')
            root_logger.setLevel(logging.DEBUG)
        if data == "nodebug":
            root_logger = logging.getLogger('')
            root_logger.setLevel(logging.INFO)
        if data == "quit":
            QUIT_FLAG = True


def is_master(sock_fd):
    if sock_fd in MASTER_LIST:
        return True
    return False


def identify_client(sock, task_queue, client_buffer):
    client = sim_chat_lib.parse_client_connect(sock, task_queue, client_buffer)
    if client:
        CHAT_CLIENT_LIST[sock.fileno()] = client
        ident = client.ident()
        if CHAT_CLIENT_IDENT_LIST.get(ident):
            close_socket(CHAT_CLIENT_IDENT_LIST.get(ident))
        CHAT_CLIENT_IDENT_LIST[ident] = sock
        # SOCKET_MAP
        logger.info(client.get_client_details())
        send_to_masters(client.get_client_details())
    else:
        logger.error("No chat client instantiated")
        close_socket(sock)


def is_available(ident):
    if CHAT_CLIENT_IDENT_LIST.get(ident):
        return True
    return False


def get_client(ident):
    if CHAT_CLIENT_IDENT_LIST.get(ident):
        if CHAT_CLIENT_LIST.get(CHAT_CLIENT_IDENT_LIST.get(ident).fileno()):
            return CHAT_CLIENT_LIST.get(CHAT_CLIENT_IDENT_LIST.get(ident).fileno())
    return None


def chat_server(port, task_queue, result_queue, disconnect_unidentified):
    global QUIT_FLAG
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((HOST, port))
    server_socket.listen(10)
    server_socket.setblocking(0)

    logger.info("Chat server started on port " + str(PORT))

    epoll.register(server_socket.fileno(), select.EPOLLIN | select.EPOLLET)
    logger.debug("Result queue file descriptor is %s", result_queue._reader.fileno())
    epoll.register(result_queue._reader, select.EPOLLIN)
    epoll.register(sys.stdin, select.EPOLLIN)

    QUIT_FLAG = False

    while not QUIT_FLAG:
        events = epoll.poll(1)
        for sock_fd, event in events:

        # get the list sockets which are ready to be read through select
        # 4th arg, time_out  = 0 : poll and never block
        # ready_to_read, ready_to_write, in_error = select.select(SOCKET_LIST, [], [], 30)

        # for sock in ready_to_read:
            # a new connection request recieved
            logger.debug("Testing if result queue reader")
            if result_queue and sock_fd == result_queue._reader.fileno():
                logger.debug("Is a result queue reader")
                response = get_result(result_queue)
                if response and response.get("imei"):
                    if is_available("imei-%s" % (response["imei"],)):
                        if response.get("type") == "config":
                            client = get_client("imei-%s" % (response["imei"],))
                            client.parse_config(response["response"])
                        # response.parser(response.result)
                    else:
                        logger.error("Device %s is no longer available for response", response.get("imei"))
                else:
                    logger.error("Unable to deliver response %s", response)

            elif sock_fd == server_socket.fileno():
                imei = None
                version = None
                proto_version = 1
                seed = None
                login_hash = None
                device_name = None
                connection, addr = server_socket.accept()
                connections[connection.fileno()] = connection
                epoll.register(connection, select.EPOLLIN | select.EPOLLET)
                logger.info("Client (%s, %s) connected" % addr)
                logger.info("New client has fd %s", connection.fileno())
                try:
                    connection.settimeout(0.5)
                    imei_line = connection.recv(1024)
                    if not imei_line:
                        logger.error("No data on connect.")
                        close_socket(connection)
                    else:
                        imei_line = imei_line.decode()

                        connection.settimeout(None)
                        if 'M@ST#R:' in imei_line[0:7] and (addr[0] == "127.0.0.1" or addr[0][0:6] == "172.17"):
                            logger.info("New master connection from %s:%s" % addr)
                            send_to_masters("New master connection from %s:%s" % addr)
                            MASTER_LIST.append(connection)
                        else:
                            logger.debug(imei_line)
                            identify_client(connection, task_queue, imei_line)

                except socket.timeout as err:
                    if disconnect_unidentified:
                        logger.error("No imei in timeout period from IP: %s:%s. Closing" % addr)
                        send_to_masters("No imei in timeout period from IP: %s:%s. Closing" % addr)
                        close_socket(connection)
                    else:
                        logger.error("No connect string but keeping connection alive.")
                except UnicodeDecodeError as err:
                    logger.error(
                        "Chat protocol exception unable to convert bytes IP: %s:%s. Closing: %s" % (
                            addr[0], addr[1], err
                         )
                    )
                    send_to_masters(
                        "Chat protocol exception unable to convert bytes IP: %s:%s. Closing: %s" % (
                            addr[0], addr[1], err
                        )
                    )
                    close_socket(connection)
                except SimChatError as err:
                    logger.error(
                        "Chat protocol exception from IP: %s:%s. Closing: %s" % (addr[0], addr[1], err.message)
                    )
                    send_to_masters(
                        "Chat protocol exception from IP: %s:%s. Closing: %s" % (addr[0], addr[1], err.message)
                    )
                    close_socket(connection)

                    # broadcast(server_socket, sock_fd, "[%s:%s] entered our chatting room\n" % addr)

            elif event & select.EPOLLIN:
                logger.debug("Is an epollin event")
                if sock_fd == sys.stdin:
                    data = sys.stdin.readline().rstrip()
                    if data:
                        execute_command(data)
    #                broadcast(server_socket, sock, "\r" + '[master] ' + data)
                # a message from a client, not a new connection
                else:
                    # process data recieved from client,
                    try:
                        # receiving data from the socket.
                        logger.debug("Received data on socket %s", sock_fd)
                        if is_master(connections[sock_fd]):
                            data = connections[sock_fd].recv(RECV_BUFFER)
                            if not data:
                                close_socket(connections[sock_fd])
                            else:
                                execute_command(data.decode().rstrip())

                        elif CHAT_CLIENT_LIST.get(sock_fd):
                            logger.debug("Found a client in the list %s", CHAT_CLIENT_LIST.get(sock_fd))
                            result = CHAT_CLIENT_LIST.get(sock_fd).receive_data()
                            logger.debug("Received the following data: %s", result)
                            if result:
                                logger.debug("Result is ok, sending to masters")
                                send_to_masters(result)
                        else:
                            logger.debug("Must be data to read but not on an expected fd")
                            data = connections[sock_fd].recv(RECV_BUFFER)
                            if data:
                               logger.error("Spurious data: %s", data)
                               identify_client(connections[sock_fd], task_queue, data.decode())
                            else:
                               close_socket(connections[sock_fd])
                               send_to_masters("Client (%s, %s) is offline\n" % addr)
                            # at this stage, no data means probably the connection has been broken
                            # broadcast(server_socket, connections[sock_fd], "Client (%s, %s) is offline\n" % addr)
                            # exception
                    except socket.error as err:
                        logger.info("Client (%s, %s) is offline" % addr)
                        close_socket(connections[sock_fd])
                        send_to_masters("Client (%s, %s) is offline" % addr)
                        # broadcast(server_socket, sock, "Client (%s, %s) is offline\n" % addr)
                    except SimChatError as err:
                        logger.error(
                            "Chat protocol exception (%s). Closing: %s" % (err.message, sock_fd)
                        )
                        send_to_masters(
                            "Chat protocol exception (%s). Closing: %s" % (err.message, sock_fd)
                        )
                        close_socket(connections[sock_fd])
            elif event & select.EPOLLOUT:
                logger.debug("Is an epollout event, with fd %s", sock_fd)
            elif event & select.EPOLLHUP:
                logger.debug("Is an epollhup event")

    stop_consumers(task_queue)

    server_socket.close()


def send_to_masters(data):
    logger.debug("Sending %s to masters", data)
    for sock_fd in MASTER_LIST:
        try:
            sock_fd.send(data.encode())
            sock_fd.send('\n'.encode())
        except socket.error:
            close_socket(connections[sock_fd])
    logger.debug("Done sending data to masters")


def send_to_device(ident, cmd):
    peer = ('None', 'None')
    if ident == "bc":
        for sock_fd in CHAT_CLIENT_LIST:
            if CHAT_CLIENT_LIST[sock_fd]:
                try:
                    if cmd == "info":
                        CHAT_CLIENT_LIST[sock_fd].request_client_info()
                    elif cmd == "location":
                        CHAT_CLIENT_LIST[sock_fd].request_client_location()
                    elif cmd == "photo_list":
                        CHAT_CLIENT_LIST[sock_fd].request_client_photo_list()
                    else:
                        CHAT_CLIENT_LIST[sock_fd].send_command(cmd)
                except socket.error as err:
                    close_socket(connections[sock_fd])

    elif CHAT_CLIENT_IDENT_LIST.get(ident):
        try:
            if cmd == "info":
                CHAT_CLIENT_LIST[CHAT_CLIENT_IDENT_LIST.get(ident)].request_client_info()
            elif cmd == "location":
                CHAT_CLIENT_LIST[CHAT_CLIENT_IDENT_LIST.get(ident)].request_client_location()
            else:
                CHAT_CLIENT_LIST[CHAT_CLIENT_IDENT_LIST.get(ident)].send_command(cmd)

        except socket.error as err:
            close_socket(CHAT_CLIENT_IDENT_LIST.get(ident))

    else:
        logger.error("Unable to send to any clients.")
        send_to_masters("Unable to send to any clients.")


# broadcast chat messages to all connected clients
def broadcast(server_socket, sock, message):
    for sock_fd in connections:
        # send the message only to peer
        if sock_fd != server_socket and sock_fd != sock and sock_fd != sys.stdin:
            try:
                if connections[sock_fd]:
                    connections[sock_fd].send(message.encode())
                # sock_fd.send(message.encode())
            except:
                # broken socket connection
                close_socket(connections[sock_fd])


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument(
        '-d',
        '--disconnect-unidentified',
        help="Disconnect clients that have not identified themselves in the first timeout period.",
        action="store_true",
        default=False,
    )

    parser.add_argument(
        '-l',
        '--line-numbers',
        help="Include line numbers in logging output",
        action="store_true",
        default=False,
    )
    parser.add_argument(
        '-p',
        '--port',
        help="The port for the webserver to listen on.",
        type=int,
        default=65533,
    )
    parser.add_argument(
        '-s',
        '--server',
        help="The django host to send the data to.",
        default=os.environ.get("GEO_API_HOST", "localhost:8000"),
    )
    parser.add_argument(
        '-v',
        dest='debug',
        help=("Increase the logging level. Can specify this option multiple "
              "times for more detail."),
        action="count",
        default=0,
    )

    args = parser.parse_args()

    log_level = 11 - args.debug

    logger = logging.getLogger('')
    logger.setLevel(logging.INFO)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    if args.line_numbers:
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(lineno)d - %(message)s'
        )
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    if args.debug:
        logger.setLevel(log_level)
        ch.setLevel(log_level)

    set_api_host(args.server)

    report_task_queue, result_queue = start_consumers(bin_results=False)
    # report_task_queue, result_queue = start_consumers()

    logger.info("Task queue is %s", report_task_queue)
    logger.info("Result queue is %s", result_queue)
    sys.exit(chat_server(args.port, report_task_queue, result_queue, args.disconnect_unidentified))
