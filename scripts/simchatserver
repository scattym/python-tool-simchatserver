#!/usr/bin/env python

# chat_server.py
import sys
import socket
import select
import argparse
import logging
import os
from sim_chat_lib.geotool_api.common import set_api_host

import sim_chat_lib
from sim_chat_lib.exception import Error as SimChatError
from sim_chat_lib.exception import ProtocolError
from sim_chat_lib.report.async_api import start_consumers, get_result, stop_consumers

HOST = ''
SOCKET_LIST = []
RECV_BUFFER = 4096
PORT = 65533

MASTER_LIST = []
logger = logging.getLogger(__name__)

CHAT_CLIENT_LIST = {}
CHAT_CLIENT_IDENT_LIST = {}

QUIT_FLAG = False


def close_socket(sock_fd):
    logger.debug("Closing socket %s", sock_fd)
    peer = [None, None]
    try:
        peer = sock_fd.getpeername()
    except socket.error as err:
        logger.error("Socket error on getting peer %s", err)

    # for key in SOCKET_MAP:
    #     if SOCKET_MAP[key] == sock_fd:
    #         logger.info("Client %s (%s, %s) is offline", key, peer[0], peer[1])
    #         SOCKET_MAP[key] = None

    if CHAT_CLIENT_LIST.get(sock_fd):
        logger.debug("Found the socket in the chat client list")
        ident = CHAT_CLIENT_LIST[sock_fd].ident()
        CHAT_CLIENT_IDENT_LIST[ident] = None
        CHAT_CLIENT_LIST[sock_fd] = None

    if sock_fd in MASTER_LIST:
        logger.info("Master disconnected from %s", sock_fd)
        MASTER_LIST.remove(sock_fd)
        # return
    if sock_fd in SOCKET_LIST:
        logger.info("Disconnecting client socket %s", sock_fd)
        SOCKET_LIST.remove(sock_fd)

    logger.debug("Socket list is now: %s", SOCKET_LIST)

    try:
        sock_fd.close()
        logger.info("Socket closed")
    except socket.error as err:
        logger.error("Socket error on close %s", err)


def execute_command(data):
    global QUIT_FLAG
    logger.info("Executing command: %s", data)
    if ',' in data:
        line = data.split(",", 1)
        imei = line[0]
        cmd = line[1]
        send_to_device(imei, cmd)
    else:
        if data == "list":
            for sock in MASTER_LIST:
                try:
                    peer = sock.getpeername()
                    logger.info("Master is connected from %s:%s" % (peer[0], peer[1]))
                    send_to_masters("Master is connected from %s:%s" % (peer[0], peer[1]))
                except socket.error:
                    close_socket(sock)
            logger.debug("%s", CHAT_CLIENT_LIST)
            for sock_fd in CHAT_CLIENT_LIST:
                logger.debug("Sockfd: %s", sock_fd)
                if CHAT_CLIENT_LIST[sock_fd]:
                    message = CHAT_CLIENT_LIST[sock_fd].get_client_details()
                    logger.debug(message)
                    send_to_masters(message)
        if data == "debug":
            root_logger = logging.getLogger('')
            root_logger.setLevel(logging.DEBUG)
        if data == "nodebug":
            root_logger = logging.getLogger('')
            root_logger.setLevel(logging.INFO)
        if data == "quit":
            QUIT_FLAG = True


def is_master(sock_fd):
    if sock_fd in MASTER_LIST:
        return True
    return False


def identify_client(sock_fd, task_queue, client_buffer):
    client = sim_chat_lib.parse_client_connect(sock_fd, task_queue, client_buffer)
    if client:
        CHAT_CLIENT_LIST[sock_fd] = client
        ident = client.ident()
        if CHAT_CLIENT_IDENT_LIST.get(ident):
            close_socket(CHAT_CLIENT_IDENT_LIST.get(ident))
        CHAT_CLIENT_IDENT_LIST[ident] = sock_fd
        # SOCKET_MAP
        logger.info(client.get_client_details())
        send_to_masters(client.get_client_details())
    else:
        logger.error("No chat client instantiated")
        close_socket(sock_fd)


def is_available(ident):
    if CHAT_CLIENT_IDENT_LIST.get(ident):
        return True
    return False


def get_client(ident):
    if CHAT_CLIENT_IDENT_LIST.get(ident):
        if CHAT_CLIENT_LIST.get(CHAT_CLIENT_IDENT_LIST.get(ident)):
            return CHAT_CLIENT_LIST.get(CHAT_CLIENT_IDENT_LIST.get(ident))
    return None


def chat_server(port, task_queue, result_queue, disconnect_unidentified):
    global QUIT_FLAG
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((HOST, port))
    server_socket.listen(10)

    # add server socket object to the list of readable connections
    SOCKET_LIST.append(server_socket)

    logger.info("Chat server started on port " + str(PORT))

    QUIT_FLAG = False
    while not QUIT_FLAG:

        # get the list sockets which are ready to be read through select
        # 4th arg, time_out  = 0 : poll and never block
        ready_to_read, ready_to_write, in_error = select.select(SOCKET_LIST, [], [], 30)

        for sock in ready_to_read:
            # a new connection request recieved
            logger.debug("Testing if result queue reader")
            if result_queue and sock == result_queue._reader:
                logger.debug("Is a result queue reader")
                response = get_result(result_queue)
                if response and response.get("imei"):
                    if is_available("imei-%s" % (response["imei"],)):
                        if response.get("type") == "config":
                            client = get_client("imei-%s" % (response["imei"],))
                            client.parse_config(response["response"])
                        # response.parser(response.result)
                    else:
                        logger.error("Device %s is no longer available for response", response.get("imei"))
                else:
                    logger.error("Unable to deliver response %s", response)

            elif sock == server_socket:
                imei = None
                version = None
                proto_version = 1
                seed = None
                login_hash = None
                device_name = None
                sock_fd, addr = server_socket.accept()
                SOCKET_LIST.append(sock_fd)
                logger.info("Client (%s, %s) connected" % addr)
                try:
                    sock_fd.settimeout(0.5)
                    imei_line = sock_fd.recv(1024)
                    if not imei_line:
                        logger.error("No data on connect.")
                        close_socket(sock_fd)
                    else:
                        imei_line = imei_line.decode()

                        sock_fd.settimeout(None)
                        if 'M@ST#R:' in imei_line[0:7] and (addr[0] == "127.0.0.1" or addr[0][0:6] == "172.17"):
                            logger.info("New master connection from %s:%s" % addr)
                            send_to_masters("New master connection from %s:%s" % addr)
                            MASTER_LIST.append(sock_fd)
                        else:
                            logger.debug(imei_line)
                            identify_client(sock_fd, task_queue, imei_line)

                except socket.timeout as err:
                    if disconnect_unidentified:
                        logger.error("No imei in timeout period from IP: %s:%s. Closing" % addr)
                        send_to_masters("No imei in timeout period from IP: %s:%s. Closing" % addr)
                        close_socket(sock_fd)
                    else:
                        logger.error("No connect string but keeping connection alive.")
                except UnicodeDecodeError as err:
                    logger.error(
                        "Chat protocol exception unable to convert bytes IP: %s:%s. Closing: %s" % (
                            addr[0], addr[1], err
                         )
                    )
                    send_to_masters(
                        "Chat protocol exception unable to convert bytes IP: %s:%s. Closing: %s" % (
                            addr[0], addr[1], err
                        )
                    )
                    close_socket(sock_fd)
                except SimChatError as err:
                    logger.error(
                        "Chat protocol exception from IP: %s:%s. Closing: %s" % (addr[0], addr[1], err.message)
                    )
                    send_to_masters(
                        "Chat protocol exception from IP: %s:%s. Closing: %s" % (addr[0], addr[1], err.message)
                    )
                    close_socket(sock_fd)

                    # broadcast(server_socket, sock_fd, "[%s:%s] entered our chatting room\n" % addr)

            elif sock == sys.stdin:
                data = sys.stdin.readline().rstrip()
                if data:
                    execute_command(data)
#                broadcast(server_socket, sock, "\r" + '[master] ' + data)
            # a message from a client, not a new connection
            else:
                # process data recieved from client,
                try:
                    # receiving data from the socket.
                    logger.debug("Received data on socket %s", sock)
                    if is_master(sock):
                        data = sock.recv(RECV_BUFFER)
                        if not data:
                            close_socket(sock)
                        else:
                            execute_command(data.decode().rstrip())

                    elif CHAT_CLIENT_LIST.get(sock):
                        logger.debug("Found a client in the list %s", CHAT_CLIENT_LIST.get(sock))
                        result = CHAT_CLIENT_LIST.get(sock).receive_data()
                        logger.debug("Received the following data: %s", result)
                        if result:
                            logger.debug("Result is ok, sending to masters")
                            send_to_masters(result)
                    else:
                        data = sock.recv(RECV_BUFFER)
                        if data:
                            logger.error("Spurious data: %s", data)
                            identify_client(sock_fd, task_queue, data.decode())
                        else:
                            close_socket(sock)
                        # at this stage, no data means probably the connection has been broken
                        # broadcast(server_socket, sock, "Client (%s, %s) is offline\n" % addr)

                        # exception
                except socket.error as err:
                    logger.info("Client (%s, %s) is offline" % addr)
                    close_socket(sock)
                    send_to_masters("Client (%s, %s) is offline" % addr)
                    # broadcast(server_socket, sock, "Client (%s, %s) is offline\n" % addr)
                except SimChatError as err:
                    logger.error(
                        "Chat protocol exception (%s). Closing: %s" % (err.message, sock)
                    )
                    send_to_masters(
                        "Chat protocol exception (%s). Closing: %s" % (err.message, sock)
                    )
                    close_socket(sock)

    stop_consumers(task_queue)

    server_socket.close()


def send_to_masters(data):
    logger.debug("Sending %s to masters", data)
    for sock_fd in MASTER_LIST:
        if sock_fd in SOCKET_LIST:
            try:
                sock_fd.send(data.encode())
                sock_fd.send('\n'.encode())
            except socket.error:
                close_socket(sock_fd)
    logger.debug("Done sending data to masters")


def send_to_device(ident, cmd):
    peer = ('None', 'None')
    if ident == "bc":
        for sock in CHAT_CLIENT_LIST:
            if CHAT_CLIENT_LIST[sock]:
                try:
                    if cmd == "info":
                        CHAT_CLIENT_LIST[sock].request_client_info()
                    elif cmd == "location":
                        CHAT_CLIENT_LIST[sock].request_client_location()
                    else:
                        CHAT_CLIENT_LIST[sock].send_command(cmd)
                except socket.error as err:
                    close_socket(sock)

    elif CHAT_CLIENT_IDENT_LIST.get(ident):
        try:
            if cmd == "info":
                CHAT_CLIENT_LIST[CHAT_CLIENT_IDENT_LIST.get(ident)].request_client_info()
            elif cmd == "location":
                CHAT_CLIENT_LIST[CHAT_CLIENT_IDENT_LIST.get(ident)].request_client_location()
            else:
                CHAT_CLIENT_LIST[CHAT_CLIENT_IDENT_LIST.get(ident)].send_command(cmd)

        except socket.error as err:
            close_socket(CHAT_CLIENT_IDENT_LIST.get(ident))

    else:
        logger.error("Unable to send to any clients.")
        send_to_masters("Unable to send to any clients.")


# broadcast chat messages to all connected clients
def broadcast(server_socket, sock, message):
    for sock_fd in SOCKET_LIST:
        # send the message only to peer
        if sock_fd != server_socket and sock_fd != sock and sock_fd != sys.stdin:
            try:
                sock_fd.send(message.encode())
            except:
                # broken socket connection
                sock_fd.close()
                # broken socket, remove it
                if sock_fd in SOCKET_LIST:
                    SOCKET_LIST.remove(socket)


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument(
        '-d',
        '--disconnect-unidentified',
        help="Disconnect clients that have not identified themselves in the first timeout period.",
        action="store_true",
        default=False,
    )

    parser.add_argument(
        '-l',
        '--line-numbers',
        help="Include line numbers in logging output",
        action="store_true",
        default=False,
    )
    parser.add_argument(
        '-p',
        '--port',
        help="The port for the webserver to listen on.",
        type=int,
        default=65533,
    )
    parser.add_argument(
        '-s',
        '--server',
        help="The django host to send the data to.",
        default=os.environ.get("GEO_API_HOST", "localhost:8000"),
    )
    parser.add_argument(
        '-v',
        dest='debug',
        help=("Increase the logging level. Can specify this option multiple "
              "times for more detail."),
        action="count",
        default=0,
    )

    args = parser.parse_args()

    log_level = 11 - args.debug

    logger = logging.getLogger('')
    logger.setLevel(logging.INFO)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    if args.line_numbers:
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(lineno)d - %(message)s'
        )
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    if args.debug:
        logger.setLevel(log_level)
        ch.setLevel(log_level)

    set_api_host(args.server)

    report_task_queue, result_queue = start_consumers(bin_results=False)
    # report_task_queue, result_queue = start_consumers()
    if result_queue:
        SOCKET_LIST.append(result_queue._reader)
    logger.info("Task queue is %s", report_task_queue)
    logger.info("Result queue is %s", result_queue)
    sys.exit(chat_server(args.port, report_task_queue, result_queue, args.disconnect_unidentified))
