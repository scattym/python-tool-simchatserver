#!/usr/bin/env python

# chat_server.py
import hashlib
import json
import sys
import socket
import select
import argparse
import logging
import datetime
import sim_chat_lib
from sim_chat_lib.exception import Error as SimChatError

HOST = ''
SOCKET_LIST = []
RECV_BUFFER = 4096
PORT = 65533

MASTER_LIST = []
logger = logging.getLogger(__name__)

CHAT_CLIENT_LIST = {}
CHAT_CLIENT_IDENT_LIST = {}


def close_socket(sock_fd):
    peer = [None, None]
    try:
        peer = sock_fd.getpeername()
    except socket.error as err:
        logger.error("Socket error on getting peer %s", err)

    # for key in SOCKET_MAP:
    #     if SOCKET_MAP[key] == sock_fd:
    #         logger.info("Client %s (%s, %s) is offline", key, peer[0], peer[1])
    #         SOCKET_MAP[key] = None

    if CHAT_CLIENT_LIST.get(sock_fd):
        ident = CHAT_CLIENT_LIST[sock_fd].ident()
        CHAT_CLIENT_IDENT_LIST[ident] = None
        CHAT_CLIENT_LIST[sock_fd] = None

    if sock_fd in MASTER_LIST:
        logger.info("Master disconnected from %s:%s", peer[0], peer[1])
        MASTER_LIST.remove(sock_fd)
        # return
    if sock_fd in SOCKET_LIST:
        logger.info("Disconnecting client socket %s", sock_fd)
        SOCKET_LIST.remove(sock_fd)

    try:
        sock_fd.close()
        logger.info("Socket closed")
    except socket.error as err:
        logger.error("Socket error on close %s", err)


def execute_command(data):
    logger.info("Executing command: %s", data)
    if ',' in data:
        line = data.split(",", 1)
        imei = line[0]
        cmd = line[1]
        send_to_device(imei, cmd)
    else:
        if data == "list":
            for sock in MASTER_LIST:
                try:
                    peer = sock.getpeername()
                    print("Master is connected from %s:%s" % (peer[0], peer[1]))
                    send_to_masters("Master is connected from %s:%s" % (peer[0], peer[1]))
                except socket.error:
                    close_socket(sock)
            logger.debug("%s", CHAT_CLIENT_LIST)
            for sock_fd in CHAT_CLIENT_LIST:
                logger.debug("Sockfd: %s", sock_fd)
                if CHAT_CLIENT_LIST[sock_fd]:
                    message = CHAT_CLIENT_LIST[sock_fd].get_client_details()
                    print(message)
                    send_to_masters(message)
        if data == "debug":
            root_logger = logging.getLogger('')
            root_logger.setLevel(logging.DEBUG)
        if data == "nodebug":
            root_logger = logging.getLogger('')
            root_logger.setLevel(logging.INFO)
        if data == "quit":
            quit_flag = True


def is_master(sock_fd):
    if sock_fd in MASTER_LIST:
        return True
    return False


def chat_server(port):
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((HOST, port))
    server_socket.listen(10)

    # add server socket object to the list of readable connections
    SOCKET_LIST.append(server_socket)

    print("Chat server started on port " + str(PORT))

    quit_flag = False
    while not quit_flag:

        # get the list sockets which are ready to be read through select
        # 4th arg, time_out  = 0 : poll and never block
        ready_to_read, ready_to_write, in_error = select.select(SOCKET_LIST, [], [], 2000)

        for sock in ready_to_read:
            # a new connection request recieved
            if sock == server_socket:
                imei = None
                version = None
                proto_version = 1
                seed = None
                login_hash = None
                device_name = None
                sock_fd, addr = server_socket.accept()
                SOCKET_LIST.append(sock_fd)
                print("Client (%s, %s) connected" % addr)
                try:
                    sock_fd.settimeout(0.5)
                    imei_line = sock_fd.recv(1024)
                    sock_fd.settimeout(None)
                    if 'M@ST#R:' in imei_line[0:7] and (addr[0] == "127.0.0.1" or addr[0][0:6] == "172.17"):
                        print("New master connection from %s:%s" % addr)
                        send_to_masters("New master connection from %s:%s" % addr)
                        MASTER_LIST.append(sock_fd)
                    else:
                        client = sim_chat_lib.parse_client_connect(sock_fd, imei_line)
                        if client:
                            CHAT_CLIENT_LIST[sock_fd] = client
                            ident = client.ident()
                            if CHAT_CLIENT_IDENT_LIST.get(ident):
                                close_socket(CHAT_CLIENT_IDENT_LIST.get(ident))
                            CHAT_CLIENT_IDENT_LIST[ident] = sock_fd
                            # SOCKET_MAP
                            print(client.get_client_details())
                            send_to_masters(client.get_client_details())
                        else:
                            logger.error("No chat client instantiated")
                            close_socket(sock_fd)
                except socket.timeout as err:
                    print("No imei in timeout period from IP: %s:%s. Closing" % addr)
                    send_to_masters("No imei in timeout period from IP: %s:%s. Closing" % addr)
                    close_socket(sock_fd)
                except SimChatError as err:
                    print(
                        "Chat protocol exception from IP: %s:%s. Closing: %s" % (addr[0], addr[1], err.message)
                    )
                    send_to_masters(
                        "Chat protocol exception from IP: %s:%s. Closing: %s" % (addr[0], addr[1], err.message)
                    )
                    close_socket(sock_fd)

                    # broadcast(server_socket, sock_fd, "[%s:%s] entered our chatting room\n" % addr)

            elif sock == sys.stdin:
                data = sys.stdin.readline().rstrip()
                execute_command(data)
#                broadcast(server_socket, sock, "\r" + '[master] ' + data)
            # a message from a client, not a new connection
            else:
                # process data recieved from client,
                try:
                    # receiving data from the socket.
                    if is_master(sock):
                        data = sock.recv(RECV_BUFFER)
                        execute_command(data.rstrip())
                    elif CHAT_CLIENT_LIST.get(sock):
                        result = CHAT_CLIENT_LIST.get(sock).receive_data()
                        if result:
                            send_to_masters(result)
                    else:
                        data = sock.read(RECV_BUFFER)
                        logger.error("Spurious data: %s", data)
                        close_socket(sock)
                        # at this stage, no data means probably the connection has been broken
                        # broadcast(server_socket, sock, "Client (%s, %s) is offline\n" % addr)

                        # exception
                except socket.error as err:
                    print("Client (%s, %s) is offline" % addr)
                    close_socket(sock)
                    send_to_masters("Client (%s, %s) is offline" % addr)
                    # broadcast(server_socket, sock, "Client (%s, %s) is offline\n" % addr)
                except SimChatError as err:
                    print(
                        "Chat protocol exception. Closing: %s" % (err.message,)
                    )
                    send_to_masters(
                        "Chat protocol exception. Closing: %s" % (err.message,)
                    )
                    close_socket(sock_fd)

    server_socket.close()


def send_to_masters(data):
    for sock_fd in MASTER_LIST:
        try:
            sock_fd.send(data)
            sock_fd.send('\n')
        except socket.error:
            close_socket(sock_fd)


def send_to_device(ident, cmd):
    peer = ('None', 'None')
    if ident == "bc":
        for sock in CHAT_CLIENT_LIST:
            try:
                CHAT_CLIENT_LIST[sock].send_command(cmd)
            except socket.error as err:
                close_socket(sock)

    elif CHAT_CLIENT_IDENT_LIST.get(ident):
        try:
            CHAT_CLIENT_LIST[CHAT_CLIENT_IDENT_LIST.get(ident)].send_command(cmd)
        except socket.error as err:
            close_socket(CHAT_CLIENT_IDENT_LIST.get(ident))

    else:
        print("Unable to send to any clients.")
        send_to_masters("Unable to send to any clients.")


# broadcast chat messages to all connected clients
def broadcast(server_socket, sock, message):
    for sock_fd in SOCKET_LIST:
        # send the message only to peer
        if sock_fd != server_socket and sock_fd != sock and sock_fd != sys.stdin:
            try:
                sock_fd.send(message)
            except:
                # broken socket connection
                sock_fd.close()
                # broken socket, remove it
                if sock_fd in SOCKET_LIST:
                    SOCKET_LIST.remove(socket)


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument(
        '-p',
        '--port',
        help="The port for the webserver to listen on.",
        type=int,
        default=65533
    )
    parser.add_argument(
        '-v',
        dest='debug',
        help=("Increase the logging level. Can specify this option multiple "
              "times for more detail."),
        action="count",
        default=0
    )

    args = parser.parse_args()

    log_level = 11 - args.debug

    logger = logging.getLogger('')
    logger.setLevel(logging.INFO)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    if args.debug:
        logger.setLevel(log_level)
        ch.setLevel(log_level)

    sys.exit(chat_server(args.port))
